/**
 * Telegram Bot Service
 * Senior PM: Complete bot with polling, user management, and broadcasting
 */

const TelegramBot = require('node-telegram-bot-api');
const config = require('../config/config');
const logger = require('../utils/logger');
const UserManagerService = require('./userManager.service');
const { MESSAGE_TEMPLATES } = require('../config/constants');
const { NotificationLog } = require('../models');

class TelegramBotService {
  constructor() {
    this.bot = null;
    this.isInitialized = false;
    this.lastBroadcastStats = {
      total: 0,
      success: 0,
      failed: 0
    };
  }
  
  /**
   * Initialize bot with polling or webhook
   */
  async initialize() {
    try {
      if (this.isInitialized) {
        return true;
      }
      
      // Clean initialization for webhook mode
      if (config.bot.webhookMode) {
        logger.info('üîß Initializing webhook mode...');
        
        // Clear any existing polling conflicts for webhook mode
        try {
          await fetch(`https://api.telegram.org/bot${config.telegram.botToken}/deleteWebhook?drop_pending_updates=true`, {
            method: 'POST'
          });
          logger.info('‚úÖ Cleared any existing webhooks/polling conflicts');
        } catch (error) {
          logger.warn('Failed to clear existing webhooks', { error: error.message });
        }
      }
      
      const options = {
        polling: config.bot.pollingEnabled,
        webHook: config.bot.webhookMode,
        request: {
          agentOptions: {
            keepAlive: true,
            family: 4
          }
        }
      };
      
      this.bot = new TelegramBot(config.telegram.botToken, options);
      
      if (config.bot.webhookMode && config.bot.webhookUrl) {
        // Set webhook for Telegram
        await this.bot.setWebHook(config.bot.webhookUrl);
        this.setupWebhookHandlers();
        logger.info('‚úÖ Telegram bot initialized with webhook', { 
          url: config.bot.webhookUrl 
        });
      } else if (config.bot.pollingEnabled) {
        this.setupPollingHandlers();
        logger.info('‚úÖ Telegram bot initialized with polling');
      } else {
        this.setupPollingHandlers(); // Fallback to polling handlers for webhook mode
        logger.info('‚úÖ Telegram bot initialized (handlers only)');
      }
      
      this.isInitialized = true;
      return true;
      
    } catch (error) {
      logger.error('‚ùå Failed to initialize Telegram bot', {
        error: error.message,
        stack: error.stack
      });
      throw error;
    }
  }
  
  /**
   * Setup webhook handlers (no-op - handled by main Express server)
   */
  setupWebhookHandlers() {
    logger.info('üì± Telegram bot webhook handlers configured (integrated with main server)');
  }
  
  /**
   * Setup polling event handlers
   */
  setupPollingHandlers() {
    // Handle /start command
    this.bot.onText(/\/start/, async (msg) => {
      await this.handleStartCommand(msg);
    });
    
    // Handle /help command
    this.bot.onText(/\/help/, async (msg) => {
      await this.handleHelpCommand(msg);
    });
    
    // Handle /status command (owners only)
    this.bot.onText(/\/status/, async (msg) => {
      await this.handleStatusCommand(msg);
    });
    
    // Handle /users command (owners only)
    this.bot.onText(/\/users/, async (msg) => {
      await this.handleUsersCommand(msg);
    });
    
    // Handle /requests command (owners only)
    this.bot.onText(/\/requests/, async (msg) => {
      await this.handleRequestsCommand(msg);
    });
    
    // Handle /ban command (owners only)
    this.bot.onText(/\/ban (.+)/, async (msg, match) => {
      await this.handleBanCommand(msg, match[1]);
    });
    
    // Handle /unban command (owners only)
    this.bot.onText(/\/unban (.+)/, async (msg, match) => {
      await this.handleUnbanCommand(msg, match[1]);
    });
    
    // Handle callback queries (inline buttons)
    this.bot.on('callback_query', async (callbackQuery) => {
      await this.handleCallbackQuery(callbackQuery);
    });
    
    // Error handling
    this.bot.on('error', (error) => {
      logger.error('Telegram bot error', {
        error: error.message,
        code: error.code
      });
    });
    
    // Polling error handling with conflict resolution
    this.bot.on('polling_error', async (error) => {
      logger.error('Telegram polling error', {
        error: error.message,
        code: error.code
      });
      
      // If it's a 409 conflict, try to resolve it
      if (error.code === 'ETELEGRAM' && error.message.includes('409 Conflict')) {
        logger.warn('üîß Attempting to resolve 409 polling conflict...');
        
        try {
          // Force set and then delete webhook to clear conflicts
          await fetch(`https://api.telegram.org/bot${config.telegram.botToken}/setWebhook`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              url: 'https://httpbin.org/post',
              drop_pending_updates: true
            })
          });
          
          await new Promise(resolve => setTimeout(resolve, 2000));
          
          await fetch(`https://api.telegram.org/bot${config.telegram.botToken}/deleteWebhook?drop_pending_updates=true`, {
            method: 'POST'
          });
          
          logger.info('‚úÖ Conflict resolution attempt completed');
        } catch (resolveError) {
          logger.warn('Failed to resolve polling conflict', { error: resolveError.message });
        }
      }
    });
    
    logger.info('üì± Telegram bot polling handlers configured');
  }
  
  /**
   * Handle /start command
   */
  async handleStartCommand(msg) {
    const user = msg.from;
    const chatId = msg.chat.id;
    
    try {
      logger.info('Start command received', {
        userId: user.id,
        username: user.username,
        chatType: msg.chat.type
      });
      
      // Only allow private chats
      if (msg.chat.type !== 'private') {
        return;
      }
      
      // Create or update user
      const dbUser = await UserManagerService.createOrUpdateUser(user);
      
      if (UserManagerService.isOwner(user.id)) {
        // Owner welcome message
        const message = `üëë *–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å, –í–ª–∞–¥–µ–ª–µ—Ü!*\n\n` +
                       `–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:\n` +
                       `/status - –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π\n` +
                       `/users - –°–ø–∏—Å–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π\n` +
                       `/requests - –ó–∞—è–≤–∫–∏ –Ω–∞ –≤—Å—Ç—É–ø–ª–µ–Ω–∏–µ\n` +
                       `/ban <user\\_id> - –ó–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è\n` +
                       `/unban <user\\_id> - –†–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è\n\n` +
                       `–ë–æ—Ç –≥–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ! üöÄ`;
        
        await this.sendMessage(chatId, message, { parse_mode: 'Markdown' });
        
      } else if (dbUser.status === 'approved') {
        // Approved user message
        const message = `‚úÖ *–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å!*\n\n` +
                       `–í–∞—à –¥–æ—Å—Ç—É–ø –∫ –±–æ—Ç—É –æ–¥–æ–±—Ä–µ–Ω.\n` +
                       `–í—ã –±—É–¥–µ—Ç–µ –ø–æ–ª—É—á–∞—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ –¥–µ–ø–æ–∑–∏—Ç–∞—Ö.\n\n` +
                       `–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /help –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å–ø—Ä–∞–≤–∫–∏.`;
        
        await this.sendMessage(chatId, message, { parse_mode: 'Markdown' });
        
      } else if (dbUser.status === 'pending') {
        // Pending user - create join request
        const requestResult = await UserManagerService.createJoinRequest(user);
        
        if (requestResult.success) {
          // Escape Markdown special characters in user data
          const firstName = this._escapeMarkdown(user.first_name || '–ù–µ —É–∫–∞–∑–∞–Ω–æ');
          const lastName = this._escapeMarkdown(user.last_name || '');
          const username = this._escapeMarkdown(user.username || '–ù–µ —É–∫–∞–∑–∞–Ω');
          
          const message = `üìù *–ó–∞—è–≤–∫–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞*\n\n` +
                         `–í–∞—à–∞ –∑–∞—è–≤–∫–∞ –Ω–∞ –¥–æ—Å—Ç—É–ø –∫ –±–æ—Ç—É –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ –≤–ª–∞–¥–µ–ª—å—Ü–∞–º.\n` +
                         `–û–∂–∏–¥–∞–π—Ç–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è.\n\n` +
                         `*–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –≤–∞—Å:*\n` +
                         `üë§ –ò–º—è: ${firstName} ${lastName}\n` +
                         `üîñ –ù–∏–∫: @${username}\n` +
                         `üÜî ID: \`${user.id}\``;
          
          await this.sendMessage(chatId, message, { parse_mode: 'Markdown' });
          
          // Notify owners about new request
          await this.notifyOwnersAboutNewRequest(user, requestResult.request);
          
        } else {
          await this.sendMessage(chatId, requestResult.message);
        }
        
      } else if (dbUser.status === 'rejected') {
        const message = `‚ùå *–î–æ—Å—Ç—É–ø –æ—Ç–∫–ª–æ–Ω–µ–Ω*\n\n` +
                       `–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, –≤–∞—à–∞ –∑–∞—è–≤–∫–∞ –Ω–∞ –¥–æ—Å—Ç—É–ø –∫ –±–æ—Ç—É –±—ã–ª–∞ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∞.`;
        
        await this.sendMessage(chatId, message, { parse_mode: 'Markdown' });
        
      } else if (dbUser.status === 'banned') {
        const message = `üö´ *–î–æ—Å—Ç—É–ø –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω*\n\n` +
                       `–í–∞—à –¥–æ—Å—Ç—É–ø –∫ –±–æ—Ç—É –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω.`;
        
        await this.sendMessage(chatId, message, { parse_mode: 'Markdown' });
      }
      
    } catch (error) {
      logger.error('Error handling start command', {
        userId: user.id,
        error: error.message
      });
      
      await this.sendMessage(chatId, '‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.');
    }
  }
  
  /**
   * Handle /help command
   */
  async handleHelpCommand(msg) {
    const chatId = msg.chat.id;
    const user = msg.from;
    
    if (msg.chat.type !== 'private') return;
    
    let message = `‚ÑπÔ∏è *–°–ø—Ä–∞–≤–∫–∞ –ø–æ –±–æ—Ç—É*\n\n`;
    
    if (UserManagerService.isOwner(user.id)) {
      message += `*–ö–æ–º–∞–Ω–¥—ã –≤–ª–∞–¥–µ–ª—å—Ü–∞:*\n` +
                `/status - –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π\n` +
                `/users - –°–ø–∏—Å–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π\n` +
                `/requests - –ó–∞—è–≤–∫–∏ –Ω–∞ –≤—Å—Ç—É–ø–ª–µ–Ω–∏–µ\n` +
                `/ban <user\\_id> - –ó–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è\n` +
                `/unban <user\\_id> - –†–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è\n\n` +
                `*–û–±—â–∏–µ –∫–æ–º–∞–Ω–¥—ã:*\n` +
                `/help - –≠—Ç–∞ —Å–ø—Ä–∞–≤–∫–∞\n\n` +
                `–ë–æ—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ –¥–µ–ø–æ–∑–∏—Ç–∞—Ö –≤—Å–µ–º –æ–¥–æ–±—Ä–µ–Ω–Ω—ã–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º.`;
    } else {
      message += `*–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:*\n` +
                `/help - –≠—Ç–∞ —Å–ø—Ä–∞–≤–∫–∞\n\n` +
                `–ë–æ—Ç –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ –¥–µ–ø–æ–∑–∏—Ç–∞—Ö.\n` +
                `–ï—Å–ª–∏ —É –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ /start –¥–ª—è –ø–æ–¥–∞—á–∏ –∑–∞—è–≤–∫–∏.`;
    }
    
    await this.sendMessage(chatId, message, { parse_mode: 'Markdown' });
  }
  
  /**
   * Handle /status command (owners only)
   */
  async handleStatusCommand(msg) {
    const chatId = msg.chat.id;
    const user = msg.from;
    
    if (msg.chat.type !== 'private') return;
    
    if (!UserManagerService.isOwner(user.id)) {
      await this.sendMessage(chatId, '‚ùå –ö–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –≤–ª–∞–¥–µ–ª—å—Ü–∞–º');
      return;
    }
    
    try {
      const stats = await UserManagerService.getUserStats();
      
      const message = `üìä *–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π*\n\n` +
                     `üë• –í—Å–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: ${stats.total}\n` +
                     `‚úÖ –û–¥–æ–±—Ä–µ–Ω–æ: ${stats.approved}\n` +
                     `‚è≥ –û–∂–∏–¥–∞–µ—Ç: ${stats.pending}\n` +
                     `‚ùå –û—Ç–∫–ª–æ–Ω–µ–Ω–æ: ${stats.rejected}\n` +
                     `üö´ –ó–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–æ: ${stats.banned}\n` +
                     `üëë –í–ª–∞–¥–µ–ª—å—Ü–µ–≤: ${stats.owners}\n\n` +
                     `üìù –ù–æ–≤—ã—Ö –∑–∞—è–≤–æ–∫: ${stats.pendingRequests}\n\n` +
                     `üìà –ü–æ—Å–ª–µ–¥–Ω—è—è —Ä–∞—Å—Å—ã–ª–∫–∞:\n` +
                     `‚îî –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ: ${this.lastBroadcastStats.success}/${this.lastBroadcastStats.total}`;
      
      await this.sendMessage(chatId, message, { parse_mode: 'Markdown' });
      
    } catch (error) {
      logger.error('Error handling status command', {
        userId: user.id,
        error: error.message
      });
      await this.sendMessage(chatId, '‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏');
    }
  }
  
  /**
   * Handle /users command (owners only)
   */
  async handleUsersCommand(msg) {
    const chatId = msg.chat.id;
    const user = msg.from;
    
    if (msg.chat.type !== 'private') return;
    
    if (!UserManagerService.isOwner(user.id)) {
      await this.sendMessage(chatId, '‚ùå –ö–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –≤–ª–∞–¥–µ–ª—å—Ü–∞–º');
      return;
    }
    
    try {
      const users = await UserManagerService.getAllUsers();
      
      if (users.length === 0) {
        await this.sendMessage(chatId, 'üì≠ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –Ω–µ –Ω–∞–π–¥–µ–Ω–æ');
        return;
      }
      
      // Group users by status
      const groupedUsers = {
        approved: users.filter(u => u.status === 'approved'),
        pending: users.filter(u => u.status === 'pending'),
        rejected: users.filter(u => u.status === 'rejected'),
        banned: users.filter(u => u.status === 'banned')
      };
      
      let message = `üë• *–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º–∏* (${users.length} –≤—Å–µ–≥–æ)\n\n`;
      
      // Approved users
      if (groupedUsers.approved.length > 0) {
        message += `‚úÖ *–û–¥–æ–±—Ä–µ–Ω–Ω—ã–µ (${groupedUsers.approved.length}):*\n`;
        for (const u of groupedUsers.approved.slice(0, 10)) {
          const roleEmoji = u.role === 'owner' ? 'üëë' : 'üë§';
          const displayName = this._escapeMarkdown(u.username || u.first_name || String(u.id));
          message += `${roleEmoji} @${displayName} (ID: ${u.id})\n`;
        }
        if (groupedUsers.approved.length > 10) {
          message += `... –∏ –µ—â–µ ${groupedUsers.approved.length - 10}\n`;
        }
        message += '\n';
      }
      
      // Pending users  
      if (groupedUsers.pending.length > 0) {
        message += `‚è≥ *–û–∂–∏–¥–∞—é—Ç (${groupedUsers.pending.length}):*\n`;
        for (const u of groupedUsers.pending.slice(0, 5)) {
          const displayName = this._escapeMarkdown(u.username || u.first_name || String(u.id));
          message += `üë§ @${displayName} (ID: ${u.id})\n`;
        }
        if (groupedUsers.pending.length > 5) {
          message += `... –∏ –µ—â–µ ${groupedUsers.pending.length - 5}\n`;
        }
        message += '\n';
      }
      
      // Banned users
      if (groupedUsers.banned.length > 0) {
        message += `üö´ *–ó–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ (${groupedUsers.banned.length}):*\n`;
        for (const u of groupedUsers.banned.slice(0, 5)) {
          const displayName = this._escapeMarkdown(u.username || u.first_name || String(u.id));
          message += `üö´ @${displayName} (ID: ${u.id})\n`;
        }
        if (groupedUsers.banned.length > 5) {
          message += `... –∏ –µ—â–µ ${groupedUsers.banned.length - 5}\n`;
        }
        message += '\n';
      }
      
      // Management buttons
      const keyboard = {
        inline_keyboard: [
          [
            { text: 'üë• –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º–∏', callback_data: 'manage_users' },
            { text: 'üö´ –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –±–∞–Ω–∞–º–∏', callback_data: 'manage_bans' }
          ],
          [
            { text: 'üìä –ü–æ–ª–Ω–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞', callback_data: 'users_stats' }
          ]
        ]
      };
      
      await this.sendMessage(chatId, message, {
        parse_mode: 'Markdown',
        reply_markup: keyboard
      });
      
    } catch (error) {
      logger.error('Error handling users command', {
        userId: user.id,
        error: error.message
      });
      await this.sendMessage(chatId, '‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å–ø–∏—Å–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π');
    }
  }
  
  /**
   * Handle /requests command (owners only)
   */
  async handleRequestsCommand(msg) {
    const chatId = msg.chat.id;
    const user = msg.from;
    
    if (msg.chat.type !== 'private') return;
    
    if (!UserManagerService.isOwner(user.id)) {
      await this.sendMessage(chatId, '‚ùå –ö–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –≤–ª–∞–¥–µ–ª—å—Ü–∞–º');
      return;
    }
    
    try {
      const requests = await UserManagerService.getPendingRequests();
      
      if (requests.length === 0) {
        await this.sendMessage(chatId, '‚úÖ –ù–µ—Ç –Ω–æ–≤—ã—Ö –∑–∞—è–≤–æ–∫');
        return;
      }
      
      for (const request of requests) {
        // Escape Markdown special characters in user data
        const firstName = this._escapeMarkdown(request.first_name || '–ù–µ —É–∫–∞–∑–∞–Ω–æ');
        const lastName = this._escapeMarkdown(request.last_name || '');
        const username = this._escapeMarkdown(request.username || '–ù–µ —É–∫–∞–∑–∞–Ω');
        const userMessage = request.message ? this._escapeMarkdown(request.message) : '';
        
        const message = `üìù *–ù–æ–≤–∞—è –∑–∞—è–≤–∫–∞*\n\n` +
                       `üë§ –ò–º—è: ${firstName} ${lastName}\n` +
                       `üîñ –ù–∏–∫: @${username}\n` +
                       `üÜî ID: \`${request.user_id}\`\n` +
                       `üìÖ –î–∞—Ç–∞: ${request.created_at.toLocaleDateString('ru-RU')}\n` +
                       `${userMessage ? `üí¨ –°–æ–æ–±—â–µ–Ω–∏–µ: ${userMessage}` : ''}`;
        
        const keyboard = {
          inline_keyboard: [
            [
              { text: '‚úÖ –û–¥–æ–±—Ä–∏—Ç—å', callback_data: `approve_${request.id}` },
              { text: '‚ùå –û—Ç–∫–ª–æ–Ω–∏—Ç—å', callback_data: `reject_${request.id}` }
            ]
          ]
        };
        
        await this.sendMessage(chatId, message, {
          parse_mode: 'Markdown',
          reply_markup: keyboard
        });
      }
      
    } catch (error) {
      logger.error('Error handling requests command', {
        userId: user.id,
        error: error.message
      });
      await this.sendMessage(chatId, '‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∑–∞—è–≤–æ–∫');
    }
  }
  
  /**
   * Handle callback queries (inline buttons)
   */
  async handleCallbackQuery(callbackQuery) {
    const chatId = callbackQuery.message.chat.id;
    const userId = callbackQuery.from.id;
    const data = callbackQuery.data;
    
    try {
      if (!UserManagerService.isOwner(userId)) {
        await this.bot.answerCallbackQuery(callbackQuery.id, {
          text: '‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤',
          show_alert: true
        });
        return;
      }
      
      // Handle different callback patterns
      if (data.startsWith('approve_') || data.startsWith('reject_')) {
        const [action, requestId] = data.split('_');
        const result = await UserManagerService.processJoinRequest(
          parseInt(requestId),
          action,
          userId
        );
        
        if (result.success) {
          // Update message with proper escaping
          const statusEmoji = action === 'approve' ? '‚úÖ' : '‚ùå';
          const statusMessage = this._escapeMarkdown(`${statusEmoji} ${result.message}`);
          const newMessage = callbackQuery.message.text + `\n\n${statusMessage}`;
          
          await this.bot.editMessageText(newMessage, {
            chat_id: chatId,
            message_id: callbackQuery.message.message_id,
            parse_mode: 'Markdown'
          });
          
          // Notify user about decision
          if (result.user) {
            await this.notifyUserAboutDecision(result.user, result.action);
          }
          
          await this.bot.answerCallbackQuery(callbackQuery.id, {
            text: result.message
          });
          
        } else {
          await this.bot.answerCallbackQuery(callbackQuery.id, {
            text: result.message,
            show_alert: true
          });
        }
      } else if (data === 'manage_users') {
        // Show user management options
        await this.showUserManagement(chatId);
        await this.bot.answerCallbackQuery(callbackQuery.id);
        
      } else if (data === 'manage_bans') {
        // Show ban management options
        await this.showBanManagement(chatId);
        await this.bot.answerCallbackQuery(callbackQuery.id);
        
      } else if (data === 'users_stats') {
        // Show detailed user statistics
        await this.showUserStats(chatId);
        await this.bot.answerCallbackQuery(callbackQuery.id);
        
      } else if (data.startsWith('ban_user_')) {
        const targetUserId = data.split('_')[2];
        const result = await UserManagerService.banUser(parseInt(targetUserId), userId);
        
        await this.bot.answerCallbackQuery(callbackQuery.id, {
          text: result.message,
          show_alert: true
        });
        
        if (result.success) {
          await this.showBanManagement(chatId);
        }
        
      } else if (data.startsWith('unban_user_')) {
        const targetUserId = data.split('_')[2];
        const result = await UserManagerService.unbanUser(parseInt(targetUserId), userId);
        
        await this.bot.answerCallbackQuery(callbackQuery.id, {
          text: result.message,
          show_alert: true
        });
        
        if (result.success) {
          await this.showBanManagement(chatId);
        }
      }
      
    } catch (error) {
      logger.error('Error handling callback query', {
        userId,
        data,
        error: error.message
      });
      
      await this.bot.answerCallbackQuery(callbackQuery.id, {
        text: '‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞',
        show_alert: true
      });
    }
  }
  
  /**
   * Handle /ban command (owners only)
   */
  async handleBanCommand(msg, userIdStr) {
    const chatId = msg.chat.id;
    const ownerId = msg.from.id;
    
    if (msg.chat.type !== 'private') return;
    
    if (!UserManagerService.isOwner(ownerId)) {
      await this.sendMessage(chatId, '‚ùå –ö–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –≤–ª–∞–¥–µ–ª—å—Ü–∞–º');
      return;
    }
    
    try {
      const userId = parseInt(userIdStr);
      if (isNaN(userId)) {
        await this.sendMessage(chatId, '‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è');
        return;
      }
      
      const result = await UserManagerService.banUser(userId, ownerId);
      
      if (result.success) {
        const username = this._escapeMarkdown(result.user.username || '–ù–µ —É–∫–∞–∑–∞–Ω');
        const message = `üö´ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω\n\n` +
                       `ID: \`${userId}\`\n` +
                       `–ù–∏–∫: @${username}`;
        
        await this.sendMessage(chatId, message, { parse_mode: 'Markdown' });
        
        // Notify banned user
        try {
          await this.sendMessage(userId, 'üö´ –í–∞—à –¥–æ—Å—Ç—É–ø –∫ –±–æ—Ç—É –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω.');
        } catch (e) {
          // User might have blocked the bot
        }
        
      } else {
        await this.sendMessage(chatId, `‚ùå ${result.message}`);
      }
      
    } catch (error) {
      logger.error('Error handling ban command', {
        ownerId,
        userIdStr,
        error: error.message
      });
      await this.sendMessage(chatId, '‚ùå –û—à–∏–±–∫–∞ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è');
    }
  }
  
  /**
   * Handle /unban command (owners only)
   */
  async handleUnbanCommand(msg, userIdStr) {
    const chatId = msg.chat.id;
    const ownerId = msg.from.id;
    
    if (msg.chat.type !== 'private') return;
    
    if (!UserManagerService.isOwner(ownerId)) {
      await this.sendMessage(chatId, '‚ùå –ö–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –≤–ª–∞–¥–µ–ª—å—Ü–∞–º');
      return;
    }
    
    try {
      const userId = parseInt(userIdStr);
      if (isNaN(userId)) {
        await this.sendMessage(chatId, '‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è');
        return;
      }
      
      const result = await UserManagerService.unbanUser(userId, ownerId);
      
      if (result.success) {
        const username = this._escapeMarkdown(result.user.username || '–ù–µ —É–∫–∞–∑–∞–Ω');
        const message = `‚úÖ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω\n\n` +
                       `ID: \`${userId}\`\n` +
                       `–ù–∏–∫: @${username}`;
        
        await this.sendMessage(chatId, message, { parse_mode: 'Markdown' });
        
        // Notify unbanned user
        try {
          await this.sendMessage(userId, '‚úÖ –í–∞—à –¥–æ—Å—Ç—É–ø –∫ –±–æ—Ç—É –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω!');
        } catch (e) {
          // User might have blocked the bot
        }
        
      } else {
        await this.sendMessage(chatId, `‚ùå ${result.message}`);
      }
      
    } catch (error) {
      logger.error('Error handling unban command', {
        ownerId,
        userIdStr,
        error: error.message
      });
      await this.sendMessage(chatId, '‚ùå –û—à–∏–±–∫–∞ —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è');
    }
  }
  
  /**
   * Send deposit notification to all approved users
   */
  async sendDepositNotification(depositData) {
    try {
      logger.info('üì± Starting deposit notification broadcast', {
        subid1: depositData.subid1,
        payout: depositData.payout,
        geo: depositData.geo
      });
      
      const users = await UserManagerService.getApprovedUsers();
      const message = this._formatDepositMessage(depositData);
      
      let successCount = 0;
      let failedCount = 0;
      
      // Send to all approved users
      for (const user of users) {
        try {
          await this.sendMessage(user.id, message, { parse_mode: 'HTML' });
          successCount++;
          
          // Small delay to avoid rate limiting
          await new Promise(resolve => setTimeout(resolve, 50));
          
        } catch (error) {
          failedCount++;
          logger.warn('Failed to send notification to user', {
            userId: user.id,
            username: user.username,
            error: error.message
          });
        }
      }
      
      // Update stats
      this.lastBroadcastStats = {
        total: users.length,
        success: successCount,
        failed: failedCount
      };
      
      // Log notification
      await NotificationLog.create({
        type: 'deposit',
        recipient_count: users.length,
        success_count: successCount,
        failed_count: failedCount,
        message_text: message,
        metadata: depositData
      });
      
      logger.info('‚úÖ Deposit notification broadcast completed', {
        total: users.length,
        success: successCount,
        failed: failedCount,
        payout: depositData.payout
      });
      
      return {
        success: true,
        stats: {
          total: users.length,
          success: successCount,
          failed: failedCount
        }
      };
      
    } catch (error) {
      logger.error('‚ùå Failed to send deposit notification', {
        error: error.message,
        depositData
      });
      
      return {
        success: false,
        error: error.message
      };
    }
  }
  
  /**
   * Format deposit message
   */
  _formatDepositMessage(data) {
    try {
      let message = MESSAGE_TEMPLATES.DEPOSIT_NOTIFICATION;
      
      const replacements = {
        '{subid1}': this._escapeHtml(data.subid1 || 'N/A'),
        '{geo}': this._escapeHtml(data.geo || 'N/A'),
        '{traffic_source_name}': this._escapeHtml(data.traffic_source_name || 'N/A'),
        '{offer_name}': this._escapeHtml(data.offer_name || 'N/A'),
        '{campaign_name}': this._escapeHtml(data.campaign_name || 'N/A'),
        '{subid2}': this._escapeHtml(data.subid2 || 'N/A'),
        '{subid4}': this._escapeHtml(data.subid4 || 'N/A'),
        '{clickId}': this._escapeHtml(data.clickId || 'N/A'),
        '{payout}': this._formatPayout(data.payout)
      };
      
      Object.entries(replacements).forEach(([placeholder, value]) => {
        message = message.replace(new RegExp(placeholder.replace(/[{}]/g, '\\$&'), 'g'), value);
      });
      
      message += `\n\n<i>üïí ${new Date().toLocaleString('ru-RU', { timeZone: 'Europe/Moscow' })}</i>`;
      
      return message;
    } catch (error) {
      logger.error('Error formatting deposit message', {
        error: error.message,
        data
      });
      
      return `ü•≥ –ù–æ–≤—ã–π –¥–µ–ø–æ–∑–∏—Ç!\n\n–ü–ª–∞—Ç–µ–ª—å—â–∏–∫: ${data.subid1 || 'N/A'}\n–°—É–º–º–∞: ${this._formatPayout(data.payout)}\n–ò—Å—Ç–æ—á–Ω–∏–∫: ${data.traffic_source_name || 'N/A'}`;
    }
  }
  
  /**
   * Notify owners about new join request
   */
  async notifyOwnersAboutNewRequest(user, request) {
    try {
      // Escape Markdown special characters in user data
      const firstName = this._escapeMarkdown(user.first_name || '–ù–µ —É–∫–∞–∑–∞–Ω–æ');
      const lastName = this._escapeMarkdown(user.last_name || '');
      const username = this._escapeMarkdown(user.username || '–ù–µ —É–∫–∞–∑–∞–Ω');
      
      const message = `üîî *–ù–æ–≤–∞—è –∑–∞—è–≤–∫–∞ –Ω–∞ –¥–æ—Å—Ç—É–ø*\n\n` +
                     `üë§ –ò–º—è: ${firstName} ${lastName}\n` +
                     `üîñ –ù–∏–∫: @${username}\n` +
                     `üÜî ID: \`${user.id}\`\n` +
                     `üìÖ –î–∞—Ç–∞: ${new Date().toLocaleDateString('ru-RU')}\n\n` +
                     `–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /requests –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∑–∞—è–≤–æ–∫.`;
      
      for (const ownerId of config.owners) {
        try {
          await this.sendMessage(ownerId, message, { parse_mode: 'Markdown' });
        } catch (error) {
          logger.warn('Failed to notify owner about new request', {
            ownerId,
            error: error.message
          });
        }
      }
    } catch (error) {
      logger.error('Error notifying owners about new request', {
        userId: user.id,
        error: error.message
      });
    }
  }
  
  /**
   * Notify user about approval/rejection decision
   */
  async notifyUserAboutDecision(user, action) {
    try {
      let message;
      
      if (action === 'approved') {
        message = `‚úÖ *–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º!*\n\n` +
                 `–í–∞—à–∞ –∑–∞—è–≤–∫–∞ –Ω–∞ –¥–æ—Å—Ç—É–ø –∫ –±–æ—Ç—É –æ–¥–æ–±—Ä–µ–Ω–∞.\n` +
                 `–¢–µ–ø–µ—Ä—å –≤—ã –±—É–¥–µ—Ç–µ –ø–æ–ª—É—á–∞—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ –¥–µ–ø–æ–∑–∏—Ç–∞—Ö.\n\n` +
                 `–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å! üéâ`;
      } else {
        message = `‚ùå *–ó–∞—è–≤–∫–∞ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∞*\n\n` +
                 `–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, –≤–∞—à–∞ –∑–∞—è–≤–∫–∞ –Ω–∞ –¥–æ—Å—Ç—É–ø –∫ –±–æ—Ç—É –±—ã–ª–∞ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∞.`;
      }
      
      await this.sendMessage(user.id, message, { parse_mode: 'Markdown' });
      
    } catch (error) {
      logger.warn('Failed to notify user about decision', {
        userId: user.id,
        action,
        error: error.message
      });
    }
  }
  
  /**
   * Send message with retry logic
   */
  async sendMessage(chatId, message, options = {}) {
    const maxRetries = 3;
    const retryDelay = 1000;
    
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        const result = await this.bot.sendMessage(chatId, message, options);
        return result;
      } catch (error) {
        const isLastAttempt = attempt === maxRetries;
        
        if (isLastAttempt) {
          throw error;
        }
        
        logger.warn(`Message send attempt ${attempt} failed`, {
          chatId,
          error: error.message,
          attempt
        });
        
        await new Promise(resolve => setTimeout(resolve, retryDelay * attempt));
      }
    }
  }
  
  /**
   * Health check
   */
  async checkHealth() {
    try {
      if (!this.bot) {
        return {
          healthy: false,
          error: 'Bot not initialized'
        };
      }
      
      const startTime = Date.now();
      const botInfo = await this.bot.getMe();
      const responseTime = Date.now() - startTime;
      
      return {
        healthy: true,
        botInfo: {
          username: botInfo.username,
          firstName: botInfo.first_name,
          id: botInfo.id
        },
        responseTime,
        isPolling: config.bot.pollingEnabled,
        lastBroadcast: this.lastBroadcastStats
      };
    } catch (error) {
      return {
        healthy: false,
        error: error.message
      };
    }
  }
  
  /**
   * Send test message to owners
   */
  async sendTestMessage() {
    try {
      const message = `üß™ <b>–¢–µ—Å—Ç —Å–∏—Å—Ç–µ–º—ã</b>\n\n` +
                     `–ë–æ—Ç —Ä–∞–±–æ—Ç–∞–µ—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ!\n\n` +
                     `<i>–í—Ä–µ–º—è: ${new Date().toLocaleString('ru-RU', { timeZone: 'Europe/Moscow' })}</i>`;
      
      let successCount = 0;
      
      for (const ownerId of config.owners) {
        try {
          await this.sendMessage(ownerId, message, { parse_mode: 'HTML' });
          successCount++;
        } catch (error) {
          logger.warn('Failed to send test message to owner', {
            ownerId,
            error: error.message
          });
        }
      }
      
      return {
        success: successCount > 0,
        sent: successCount,
        total: config.owners.length
      };
    } catch (error) {
      return {
        success: false,
        error: error.message
      };
    }
  }
  
  /**
   * Utility methods
   */
  _escapeHtml(text) {
    if (typeof text !== 'string') {
      return String(text || '');
    }
    
    return text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;');
  }
  
  _escapeMarkdown(text) {
    if (typeof text !== 'string') {
      return String(text || '');
    }
    
    // Escape special Markdown characters
    return text
      .replace(/\\/g, '\\\\')  // Backslash must be escaped first
      .replace(/\*/g, '\\*')   // Asterisk
      .replace(/_/g, '\\_')    // Underscore
      .replace(/\[/g, '\\[')   // Square brackets
      .replace(/\]/g, '\\]')
      .replace(/\(/g, '\\(')   // Parentheses
      .replace(/\)/g, '\\)')
      .replace(/~/g, '\\~')    // Tilde
      .replace(/`/g, '\\`')    // Backtick
      .replace(/>/g, '\\>')    // Greater than
      .replace(/#/g, '\\#')    // Hash
      .replace(/\+/g, '\\+')   // Plus
      .replace(/-/g, '\\-')    // Minus
      .replace(/=/g, '\\=')    // Equals
      .replace(/\|/g, '\\|')   // Pipe
      .replace(/\{/g, '\\{')   // Curly braces
      .replace(/\}/g, '\\}')
      .replace(/\./g, '\\.')   // Period
      .replace(/!/g, '\\!');   // Exclamation
  }
  
  _formatPayout(payout) {
    try {
      const amount = parseFloat(payout) || 0;
      return `$${amount.toFixed(2)}`;
    } catch (error) {
      return '$0.00';
    }
  }

  /**
   * Show user management interface
   */
  async showUserManagement(chatId) {
    try {
      const users = await UserManagerService.getAllUsers();
      const approvedUsers = users.filter(u => u.status === 'approved' && u.role !== 'owner');
      
      if (approvedUsers.length === 0) {
        await this.sendMessage(chatId, 'üì≠ –ù–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è');
        return;
      }
      
      let message = `üë• *–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º–∏*\n\n`;
      message += `–í—ã–±–µ—Ä–∏—Ç–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–ª—è –¥–µ–π—Å—Ç–≤–∏–π:\n\n`;
      
      const keyboard = {
        inline_keyboard: []
      };
      
      // Show first 8 users with buttons
      for (let i = 0; i < Math.min(approvedUsers.length, 8); i++) {
        const user = approvedUsers[i];
        const rawName = user.username ? `@${user.username}` : (user.first_name || `ID: ${user.id}`);
        const displayName = this._escapeMarkdown(rawName);
        
        keyboard.inline_keyboard.push([
          { text: `üö´ –ó–∞–±–∞–Ω–∏—Ç—å ${displayName}`, callback_data: `ban_user_${user.id}` }
        ]);
      }
      
      if (approvedUsers.length > 8) {
        message += `\n_–ü–æ–∫–∞–∑–∞–Ω—ã –ø–µ—Ä–≤—ã–µ 8 –∏–∑ ${approvedUsers.length} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π_`;
      }
      
      await this.sendMessage(chatId, message, {
        parse_mode: 'Markdown',
        reply_markup: keyboard
      });
      
    } catch (error) {
      logger.error('Error showing user management', { error: error.message });
      await this.sendMessage(chatId, '‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º–∏');
    }
  }

  /**
   * Show ban management interface
   */
  async showBanManagement(chatId) {
    try {
      const users = await UserManagerService.getAllUsers();
      const bannedUsers = users.filter(u => u.status === 'banned');
      
      if (bannedUsers.length === 0) {
        await this.sendMessage(chatId, '‚úÖ –ù–µ—Ç –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π');
        return;
      }
      
      let message = `üö´ *–ó–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏*\n\n`;
      
      const keyboard = {
        inline_keyboard: []
      };
      
      // Show all banned users with unban buttons
      for (const user of bannedUsers) {
        const rawName = user.username ? `@${user.username}` : (user.first_name || `ID: ${user.id}`);
        const displayName = this._escapeMarkdown(rawName);
        message += `üö´ ${displayName} (ID: ${user.id})\n`;
        
        keyboard.inline_keyboard.push([
          { text: `‚úÖ –†–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å ${displayName}`, callback_data: `unban_user_${user.id}` }
        ]);
      }
      
      await this.sendMessage(chatId, message, {
        parse_mode: 'Markdown',
        reply_markup: keyboard
      });
      
    } catch (error) {
      logger.error('Error showing ban management', { error: error.message });
      await this.sendMessage(chatId, '‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –±–∞–Ω–∞–º–∏');
    }
  }

  /**
   * Show detailed user statistics
   */
  async showUserStats(chatId) {
    try {
      const stats = await UserManagerService.getUserStats();
      const users = await UserManagerService.getAllUsers();
      
      // Calculate additional stats
      const recentUsers = users.filter(u => {
        const dayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);
        return new Date(u.created_at) > dayAgo;
      }).length;
      
      const activeUsers = users.filter(u => {
        if (!u.last_activity) return false;
        const weekAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
        return new Date(u.last_activity) > weekAgo;
      }).length;
      
      const message = `üìä *–î–µ—Ç–∞–ª—å–Ω–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π*\n\n` +
                     `üë• –í—Å–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: *${stats.total}*\n` +
                     `‚úÖ –û–¥–æ–±—Ä–µ–Ω–æ: *${stats.approved}*\n` +
                     `‚è≥ –û–∂–∏–¥–∞—é—Ç: *${stats.pending}*\n` +
                     `‚ùå –û—Ç–∫–ª–æ–Ω–µ–Ω–æ: *${stats.rejected}*\n` +
                     `üö´ –ó–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–æ: *${stats.banned}*\n` +
                     `üëë –í–ª–∞–¥–µ–ª—å—Ü—ã: *${stats.owners}*\n\n` +
                     `üìà *–ê–∫—Ç–∏–≤–Ω–æ—Å—Ç—å:*\n` +
                     `üÜï –ù–æ–≤—ã—Ö –∑–∞ 24—á: *${recentUsers}*\n` +
                     `üî• –ê–∫—Ç–∏–≤–Ω—ã—Ö –∑–∞ –Ω–µ–¥–µ–ª—é: *${activeUsers}*\n` +
                     `üìù –ó–∞—è–≤–æ–∫ –Ω–∞ —Ä–∞—Å—Å–º–æ—Ç—Ä–µ–Ω–∏–∏: *${stats.pendingRequests}*\n\n` +
                     `üìÖ –î–∞–Ω–Ω—ã–µ –∞–∫—Ç—É–∞–ª—å–Ω—ã –Ω–∞: ${new Date().toLocaleString('ru-RU', { timeZone: 'Europe/Moscow' })}`;
      
      await this.sendMessage(chatId, message, { parse_mode: 'Markdown' });
      
    } catch (error) {
      logger.error('Error showing user stats', { error: error.message });
      await this.sendMessage(chatId, '‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏');
    }
  }
}

// Create singleton instance
const telegramBotService = new TelegramBotService();

module.exports = telegramBotService;